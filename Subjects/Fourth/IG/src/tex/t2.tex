\chapter{El Motor Godot y la Gestión de Mallas Geométricas}

\section{Arquitectura del Motor Godot}

El desarrollo de aplicaciones gráficas interactivas mediante el motor Godot se fundamenta en una arquitectura jerárquica y modular. La comprensión de su estructura interna es esencial para la implementación eficiente de algoritmos gráficos.

\subsection{El Árbol de Escena (Scene Tree)}
El núcleo organizativo de Godot es el \textit{Scene Tree}. Toda aplicación se estructura como una jerarquía de nodos, donde la clase base \texttt{Node} define el comportamiento genérico.
\begin{itemize}
    \item \textbf{Node2D:} Clase base para elementos en el espacio bidimensional (coordenadas $x, y$).
    \item \textbf{Node3D:} Clase base para elementos en el espacio tridimensional (coordenadas $x, y, z$).
\end{itemize}
La composición de escenas complejas se realiza mediante la anidación de estos nodos, permitiendo la propagación de transformaciones geométricas (traslación, rotación, escalado) de padres a hijos.

\subsection{El Bucle Principal y GDScript}
El flujo de ejecución sigue el paradigma del \textit{Game Loop}. La clase \texttt{SceneTree} gestiona el ciclo de vida de la aplicación, invocando métodos críticos como \texttt{\_process(delta)} en cada fotograma para la actualización lógica y el renderizado.

El lenguaje de scripting nativo, GDScript, aunque sintácticamente similar a Python, está optimizado para la arquitectura del motor. Desde una perspectiva de ingeniería de software, se enfatiza el uso de **tipado estático** (ej. \texttt{var x: float}) frente al dinámico, permitiendo optimizaciones en tiempo de compilación y mayor robustez en el código.

\section{Fundamentos de las Mallas (Meshes)}

La unidad atómica de representación geométrica en Godot es la clase \texttt{Mesh}. Una malla no es más que una colección estructurada de primitivas geométricas que la GPU puede procesar.

\subsection{Primitivas Gráficas}
El hardware gráfico procesa secuencias de vértices interpretadas según la topología definida:
\begin{enumerate}
    \item \textbf{Puntos y Líneas:} Utilizados principalmente para depuración visual (\textit{debugging}) y representación de estructuras auxiliares (ej. normales, esqueletos).
    \item \textbf{Triángulos (\texttt{PRIMITIVE\_TRIANGLES}):} La primitiva fundamental para superficies sólidas.
    \item \textbf{Tiras de Triángulos (\texttt{TRIANGLE\_STRIP}):} Optimización topológica donde cada nuevo vértice forma un triángulo con los dos inmediatamente anteriores, reduciendo la redundancia de datos.
\end{enumerate}

\subsection{Atributos del Vértice}
Un vértice en informática gráfica es una estructura de datos compleja que excede la mera posición espacial. Incluye atributos necesarios para el sombreado (\textit{shading}):
\begin{itemize}
    \item \textbf{Posición:} Coordenadas espaciales ($P \in \mathbb{R}^3$).
    \item \textbf{Normal:} Vector unitario ($N \in \mathbb{R}^3$) perpendicular a la superficie, crítico para los cálculos de iluminación.
    \item \textbf{Color:} Valor RGBA interpolado para el sombreado de Gouraud o similares.
    \item \textbf{Coordenadas UV:} Par ordenado ($u, v$) para el mapeo de texturas.
\end{itemize}

\textit{Nota sobre Arquitectura de Memoria:} Godot implementa un diseño de **Estructura de Arrays (SOA)** en lugar de Array de Estructuras (AOS). Esto implica que los atributos se almacenan en arrays contiguos independientes (un array solo para posiciones, otro solo para normales), optimizando la localidad de caché de la GPU.

\section{Estrategias de Optimización y Renderizado}

La eficiencia en el envío de datos del procesador (CPU) a la tarjeta gráfica (GPU) es un cuello de botella habitual que se mitiga mediante técnicas específicas.

\subsection{Indexación de Vértices}
Para evitar la redundancia de datos en mallas conectadas (donde múltiples triángulos comparten un mismo vértice), se utiliza la técnica de **Mallas Indexadas**:
\begin{itemize}
    \item \textbf{Tabla de Vértices ($V$):} Almacena únicamente los vértices únicos con sus atributos pesados.
    \item \textbf{Tabla de Índices ($I$):} Array de enteros ligeros que referencian la posición en $V$ para definir la conectividad.
\end{itemize}
Esta técnica reduce drásticamente el consumo de VRAM y aprovecha la caché de vértices de la GPU.

\subsection{Modos de Envío: Inmediato vs. Diferido}
\begin{itemize}
    \item \textbf{Modo Inmediato (\texttt{ImmediateMesh}):} Los datos geométricos se envían al bus gráfico en cada fotograma. Flexible pero computacionalmente costoso. Su uso se restringe a geometría dinámica simple que cambia constantemente.
    \item \textbf{Modo Diferido (\texttt{ArrayMesh}):} Los datos se transfieren una única vez a la memoria de vídeo (VRAM). Es el estándar para modelos estáticos y personajes, ofreciendo el máximo rendimiento.
\end{itemize}

\section{Generación Procedural: SurfaceTool}

Para la construcción algorítmica de geometría compleja desde código, Godot provee la clase \texttt{SurfaceTool}. Esta herramienta abstrae la gestión manual de arrays, funcionando como una máquina de estados que permite definir atributos vértice a vértice y generar automáticamente tangentes, normales y la estructura final de la \texttt{ArrayMesh} optimizada.